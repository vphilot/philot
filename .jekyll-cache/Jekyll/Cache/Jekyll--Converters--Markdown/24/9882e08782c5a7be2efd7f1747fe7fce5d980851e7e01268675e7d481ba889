I"):<p>I’ve been trying to decouple my projects from dependencies and libraries as much as I can lately. It not only gives me a good opportunity to exercise some skills I have been neglecting but having the extra control over bugs and errors is also a welcome addition.</p>

<p>My latest adventure was the need to create a Back to Top button that would only show up after a specific element was on the page, and would then disappear when scrolled past a boundary container. Here is the basic acceptance criteria:</p>

<ul class="has-bullet">
  <li>A <strong>top container</strong> triggers the button visibility state to true when intersecting the viewport</li>
  <li>A <strong>bottom container</strong> removes the visible state from the button</li>
  <li><strong>Vanilla JS</strong> only</li>
  <li>Back to Top button has a subtle opacity transition when changing states</li>
  <li>Back to Top button cannot be clickable when hidden</li>
</ul>

<p>With these basic conditions given, let’s stretch our coding muscles and bootstrap this solution!</p>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="understanding-the-problem">Understanding the problem</h3>

<p>Considering our markup to be composed of a Back to Top Button <code class="language-plaintext highlighter-rouge">#back-to-top</code>, a top container <code class="language-plaintext highlighter-rouge">#section-top</code>, and a bottom container <code class="language-plaintext highlighter-rouge">#section-bottom</code>, let’s start by storing pointer references to these DOM Elements:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#back-to-top</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">topSection</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#section-top</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">bottomSection</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#section-bottom</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>Our first step is finding where both our section elements will intersect the page scroll flow. It seems like a simple task as you can state it as <strong><em>just find their scroll position value relative to the vertical space available on the page!</em></strong>. Well, this is the solution itself, but JavasScript doesn’t provide a specific method to find these values straight away. Instead, it provides a lot of helper methods available at the object level to deal with these types of calculations.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="kd">const</span> <span class="nx">topScrollTreshold</span> <span class="o">=</span>  <span class="nx">topSection</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">().</span><span class="nx">top</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">getBoundingClientRect</code> method can be called from a DOM element (in this case, the topSection) and will return a <code class="language-plaintext highlighter-rouge">DOMRect</code> object with properties that describe its size and its position relative to the viewport:</p>

<picture>
    
    <source type="image/webp" srcset="/assets/images/post/building-a-simple-back-to-top-button-trigger-with-css-and-javascript-1.webp" />
    <source type="image/jpeg" srcset="/assets/images/post/building-a-simple-back-to-top-button-trigger-with-css-and-javascript-1.jpg" />
    <img src="/assets/images/post/building-a-simple-back-to-top-button-trigger-with-css-and-javascript-1.jpg" alt="using element.getBoundingClientRect" title="using element.getBoundingClientRect" />
</picture>

<p>One important thing to consider is that the position properties (<code class="language-plaintext highlighter-rouge">top</code>, <code class="language-plaintext highlighter-rouge">left</code>, and so forth) returned by this method are <strong>relative to the viewport</strong> and are not aware of our total page height, which is fundamental for us to understand when the Back to Top button should show up. To work around this issue, we add the <code class="language-plaintext highlighter-rouge">top</code> value of our element to the current scroll position by accessing <code class="language-plaintext highlighter-rouge">window.PageYOffset</code>.
Property names are also important here: <code class="language-plaintext highlighter-rouge">window.pageYOffset</code> is the same as <code class="language-plaintext highlighter-rouge">window.scrollY</code>, but it has native support on IE.</p>

<p>A more in-depth look of the values <code class="language-plaintext highlighter-rouge">getBoundingClientRect</code> can also teach us that <code class="language-plaintext highlighter-rouge">padding</code> <code class="language-plaintext highlighter-rouge">and border-width</code> are added to the total width/height values if we’re using the standard box model:</p>

<picture>
    
    <source type="image/webp" srcset="/assets/images/post/building-a-simple-back-to-top-button-trigger-with-css-and-javascript-2.webp" />
    <source type="image/jpeg" srcset="/assets/images/post/building-a-simple-back-to-top-button-trigger-with-css-and-javascript-2.jpg" />
    <img src="/assets/images/post/building-a-simple-back-to-top-button-trigger-with-css-and-javascript-2.jpg" alt="using element.getBoundingClientRect" title="using element.getBoundingClientRect" />
</picture>

<p>Making use of <code class="language-plaintext highlighter-rouge">box-sizing: border-box</code> is a way to get rid of this behaviour, but for our case just being mindful of this rule is enough.</p>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="observing-if-were-already-past-the-containers">Observing if we’re already past the containers</h3>

<p>As a way of streamlining this process, we’re going to add a conditional logic to our <code class="language-plaintext highlighter-rouge">topScrollTreshold</code> so it returns a boolean. We’re now planning on making these variables live inside a <code class="language-plaintext highlighter-rouge">scroll</code> window event, so every time users scroll the variables will be checked and return a new set of values:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">topScrollTreshold</span> <span class="o">=</span> <span class="nx">topSection</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">().</span><span class="nx">top</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span> <span class="o">&lt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>We’re adding our top container <code class="language-plaintext highlighter-rouge">.top</code> property to <code class="language-plaintext highlighter-rouge">pageYOffset</code> to find its position relative to the entire page scroll, and then checking if that value is smaller than the page scroll position (<code class="language-plaintext highlighter-rouge">pageYOffset</code>). For the bottom container the logic has a little caveat:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">bottomScrollTreshold</span> <span class="o">=</span> <span class="nx">btn</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">().</span><span class="nx">top</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span> <span class="o">&gt;</span> <span class="nx">bottomSection</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">().</span><span class="nx">top</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span><span class="p">;</span>
</code></pre></div></div>
<p>Back to our requirements:</p>

<ul class="has-bullet">
  <li>A bottom container removes the visible state from the button</li>
</ul>

<p><strong>There is a chance that nothing will live below the Bottom container and it will never reach the top of the page</strong>. According to MDN:</p>

<blockquote>
  <p>The read-only Window property pageYOffset (…) returns the number of pixels the document is currently scrolled along the vertical axis (that is, up or down) with a value of 0.0, indicating that the <strong>top edge of the Document</strong> is currently aligned with the <strong>top edge of the window’s content area</strong>.</p>
</blockquote>

<p>That’s the issue with measuring its position alone as we did to the Top container. Checking its intersection with the Back to Top button is a more fail-proof choice in this case.</p>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="a-little-css">A little CSS</h3>

<p>The extra CSS to make this button work is pretty simple: in its default state (hidden), no <code class="language-plaintext highlighter-rouge">pointer-events</code> will be observed and the <code class="language-plaintext highlighter-rouge">opacity</code> is set to zero. We’re also positioning it as <code class="language-plaintext highlighter-rouge">fixed</code> relative to the viewport:</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.back-to-top</span> <span class="p">{</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">fixed</span><span class="p">;</span>
  <span class="nl">bottom</span><span class="p">:</span> <span class="m">5vh</span><span class="p">;</span>
  <span class="nl">right</span><span class="p">:</span> <span class="m">5vw</span><span class="p">;</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">opacity</span> <span class="m">0.5s</span><span class="p">;</span>
  <span class="nl">pointer-events</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.back-to-top.visible</span> <span class="p">{</span>
    <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
    <span class="nl">pointer-events</span><span class="p">:</span> <span class="n">all</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">.visible</code> class describes its active state when it’s clickable and fully opaque.</p>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="putting-it-all-together">Putting it all together</h3>

<p>The final steps are adding more simple logic to trigger our button state based on the final outcome of the threshold checkers:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//setting visibility based on scroll pos</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">topScrollTreshold</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">btn</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">visible</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">btn</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="dl">"</span><span class="s2">visible</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">btn</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="dl">"</span><span class="s2">visible</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">bottomScrollTreshold</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">btn</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="dl">"</span><span class="s2">visible</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>See the codepen below:</p>

<p class="codepen" data-height="556" data-theme-id="dark" data-default-tab="result" data-user="vphilot" data-slug-hash="jOWmpdb" data-preview="true" style="height: 556px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Simple Back to Top trigger with CSS + JS (Vanilla)">
  <span>See the Pen <a href="https://codepen.io/vphilot/pen/jOWmpdb">
  Simple Back to Top trigger with CSS + JS (Vanilla)</a> by Vinicius Philot (<a href="https://codepen.io/vphilot">@vphilot</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async="" src="https://static.codepen.io/assets/embed/ei.js"></script>

:ET