I"ˆA<p>This week when building a component I stumbled upon an issue that got the thinking a little. We needed a button that would be future proof and take users to the <strong><em>next section</em></strong> of the page, regardless of what that section would be.</p>

<p>Thereâ€™s a native implementation for this use case, the <code class="language-plaintext highlighter-rouge">nextElementSibling</code> property:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nextNode</span> <span class="o">=</span> <span class="nx">elementNodeReference</span><span class="p">.</span><span class="nx">nextElementSibling</span><span class="p">;</span> 
</code></pre></div></div>

<p>However, the native option will return <strong>any</strong>  DOM tree sibling, including scripts, styles, and other tags. For my particular case, I was looking for elements that were actually rendered on the page. Hereâ€™s the basic acceptance criteria of the function weâ€™ll be writing:</p>

<ul class="has-bullet">
  <li>We want <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> tags to be disregarded as valid results</li>
  <li>The function must check for null values (in case thereâ€™s no valid sibling)</li>
  <li><strong>Vanilla JS</strong> only</li>
</ul>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="outlining-the-function">Outlining the function</h3>

<p>Our helper function will accept an <code class="language-plaintext highlighter-rouge">element</code> argument which is the current element whose sibling we want to return:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">){}</span>
</code></pre></div></div>

<p>A pretty straightforward way of getting all of the siblings is by:</p>
<ul class="has-bullet">
  <li>Going <strong>one level up</strong> to its parent (JS property <code class="language-plaintext highlighter-rouge">parentNode</code>)</li>
  <li>Descending back again <strong>one level down</strong> to get all of the parent nodeâ€™s children (JS property <code class="language-plaintext highlighter-rouge">children</code>)</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Now we can do all sorts of mapping, sorting, and filtering methods in our <code class="language-plaintext highlighter-rouge">children</code> object to find the siblings! <strong>Except that we canâ€™t</strong>. Using <code class="language-plaintext highlighter-rouge">element.parentNode.children</code> will return a <code class="language-plaintext highlighter-rouge">NodeList</code> object that doesnâ€™t accept all the Array methods weâ€™re looking for at the moment. To make this work, we need to create a new instance of <code class="language-plaintext highlighter-rouge">Array</code> type by using the following ES6 syntax:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="filtering-the-results">Filtering the results</h3>

<p>Now that we can use the <code class="language-plaintext highlighter-rouge">filter</code> method to return find what weâ€™re looking for in the (sometimes) large children array, itâ€™s important to establish what types of DOM nodes we care about:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">siblings</span> <span class="o">=</span> <span class="nx">children</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">child</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">//but what are we looking for really?</span>
        <span class="p">})</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Since every single element in this array is a DOM <code class="language-plaintext highlighter-rouge">Node</code>, we can leverage some properties of this object to find what weâ€™re looking for.</p>

<p>The first one is <code class="language-plaintext highlighter-rouge">node.nodeType</code>. The <code class="language-plaintext highlighter-rouge">nodeType</code> property has a value that can help us identify quickly target the value <code class="language-plaintext highlighter-rouge">1</code>, which is <code class="language-plaintext highlighter-rouge">ELEMENT_NODE</code>. Many other types are available though, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType">click here to see the full NodeType reference on MDN</a>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
</code></pre></div></div>

<p>This is not enough however, as <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;style&gt;</code>, and <code class="language-plaintext highlighter-rouge">&lt;link&gt;</code>tags will still be processed as valid results. To resolve this issue, we can leverage another property of the <code class="language-plaintext highlighter-rouge">Node</code> object called <code class="language-plaintext highlighter-rouge">tagName</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">SCRIPT</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">LINK</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">STYLE</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//will return the visible, rendered elements only</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="finding-who-is-the-next-sibling">Finding who is the next sibling</h3>

<p>So far, weâ€™re able to return siblings of our element (by getting all of the children of its parent). Hereâ€™s how the function looks so far:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">siblings</span> <span class="o">=</span> <span class="nx">children</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">child</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="nx">child</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">SCRIPT</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">LINK</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">STYLE</span><span class="dl">"</span>
        <span class="p">})</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Now we need a way to find the next direct sibling of our element, considering all the elements present in the <code class="language-plaintext highlighter-rouge">siblings</code> array match our criteria. A simple way to accomplish this is by:</p>

<ul class="has-bullet">
  <li>Finding where our <strong>current element</strong> stands in the siblings <code class="language-plaintext highlighter-rouge">array</code> by getting its <code class="language-plaintext highlighter-rouge">index</code></li>
  <li>Finding what the next direct sibling is by simply adding <code class="language-plaintext highlighter-rouge">1</code> to that index</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">currentElementIndex</span> <span class="o">=</span> <span class="nx">siblings</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">nextElementIndex</span> <span class="o">=</span> <span class="nx">currentElementIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally, we add a last check just to ensure our function is returnin an element (since there is a possibility our current element is the last on its parentâ€™s hierarchy). This is how the final result looks like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">siblings</span> <span class="o">=</span> <span class="nx">children</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">child</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="nx">child</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">SCRIPT</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">LINK</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">STYLE</span><span class="dl">"</span>
        <span class="p">});</span>

        <span class="kd">const</span> <span class="nx">currentElementIndex</span> <span class="o">=</span> <span class="nx">siblings</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">nextElementIndex</span> <span class="o">=</span> <span class="nx">currentElementIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">siblings</span><span class="p">[</span><span class="nx">nextElementIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">siblings</span><span class="p">[</span><span class="nx">nextElementIndex</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 class="intro title is-3 has-text-weight-normal has-line-spacing-tall" id="working-with-ie-and-es5">Working with IE and ES5</h3>

<p>Since the <code class="language-plaintext highlighter-rouge">Array.from</code> method might return an error on Interner Explorer even when using Babel, thereâ€™s a last modification we can implement to make this function compatible with older browsers (if thatâ€™s included in your target audience):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getElementNextSibling</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span>
    <span class="c1">// everything else stays the same</span>
<span class="p">}</span>
</code></pre></div></div>
:ET